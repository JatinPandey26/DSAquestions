///////////////////////////////////////// Using Min Heap ///////////////////////////////////////////////////

  public static int meetingRooms(int intervals[][]) {
    if (intervals.length == 0) return 0;
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    int[] fm = new int[2];
    fm[0] = intervals[0][0];
    fm[1] = intervals[0][1];
    pq.add(fm);
    int ans = 0;
    for (int i = 1; i < intervals.length ; i++) {
      while (pq.size() > 0 && pq.peek()[1] <= intervals[i][0]) pq.poll();

      int[] meet = new int[2];
      meet[0] = intervals[i][0];
      meet[1] = intervals[i][1];
      pq.add(meet);

      ans = Math.max(ans, pq.size());

    }
    ans = Math.max(ans, pq.size());
    return ans;
  }
  
  
  /////////////////////////////////// CRONOLOGICAL ORDER (Min Platforms Type) ////////////////////////////////////////////// 
  
       public static int findPlatform(int[] arr, int[] dep) {
    Arrays.sort(arr);
    Arrays.sort(dep);
    
    int i = 0;
    int j = 0;
    int trains = 0;
    int platforms = 0;
    while(i < arr.length){
        
        if(arr[i] < dep[j]){
            trains++;
            i++;
        }
        else{
            platforms = Math.max(trains , platforms);
            trains--;
            j++;
        }
        
    }
    
    platforms = Math.max(trains , platforms);
    
    return platforms;
    
  }
    
  public static int meetingRooms(int interval[][]) {
    int[] strt = new int[interval.length];
    int[] end = new int[interval.length];
    
    for(int i = 0 ; i < interval.length ; i++){
        strt[i] = interval[i][0];
        end[i] = interval[i][1];
    }
    return findPlatform(strt,end);
  }
